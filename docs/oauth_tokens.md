# OAuth tokens

This document explains how are the OAuth tokens implemented and their database
layout in Redis.

OAuth tokens are used for authorization, and are generated by an external system
and sent to us so that we check them when processing OAuth authorization calls.

Basically they map a token to a given application identifier. This way, instead
of providing an application identifier or a user key, they provide an access
token that the backend has to check against.

# Design

The system works on the following assumptions, which could be subject to
discussion:

* Tokens are expected to be *UNIQUE* per service. Duplicated tokens between
  applications or users are explicitly *not* supported.

* Tokens map 1:1 to applications. No two applications can refer to the same
  token.

* Tokens can *NOT* be shared between users.

* Tokens can be application-wide or user-specific.

* Application-wide tokens are only considered for authorization when there is no
  user id associated to the request, so they cannot authorize users.

* User-specific tokens only succeed in authorizing when the user_id they relate
  to was specified in the authorization call.

# CR(U)D

## Reading ONE token (aka mapping a token to an application)

The Redis layout for mapping a token to a service is a single key-value:

`oauth_access_tokens/service:#{service_id}/#{token}`

So it depends only on a service. This key is known as the `token_key`.

For performance reasons and for supporting cheking that tokens are unique, the
key only depends on the service id, but the value can have a user id annotation.
This annotation is a prefix of the form: "user:#{user_id}/". This way we can
detect user-specific tokens.

This, as we will see below, is not strictly necessary, but it constitutes
a denormalization in order to improve performance, since this way a single
storage request will be enough for authorization purposes.

## Creating and Deleting tokens

Creation and deletion are more complex than just creating or deleting
`token_key`s. This is so because we have to support an extra feature, token
listing, without resorting to scanning the database for key pattern matching
(because that would be a no-no in production). Token listing is used by services
to manage and assign tokens.

This is why we track the list of tokens that the combination of a given service
and application have. Since tokens are unique within that combination, we use
Redis sets for storage. These sets are known as `token_set_key`.

Additionally, since users also have their own sets of authorization tokens, we
store them in sets too. Those sets are `token_set_key`s as well.

Their format is:

* `"oauth_access_tokens/service:#{service_id}/app:#{app_id}/"` for non-user sets
* `"oauth_access_tokens/service:#{service_id}/app:#{app_id}/user:#{user_id}/"`
  for user-specific sets.

The remaining question is how do we know which users have tokens. We also handle
them with a set, known as the `users_set_key`, with one instance per service and
application.

### Redis steps

When storing a new token, we add `token_key` in Redis and assign an optional TTL
to it if the token expires after a certain amount of time. The value of such key
is the application id referred, with the user specific prefix if applicable.

We also add the token to the `token_set_key` for the whole application or for
a specific user if provided. Finally, if we were provided with a user, add that
user to the `users_set_key` set.

Deletion is basically the reverse of creation with some caveats. The main
difference is that, while when creating you can safely add a duplicated user to
the `users_set_key` set, because it is idempotent, when deleting you want to
delete users from that set that got their `token_set_key` set empty.

After performing the expected delete of the token from the `token_set_key` set,
we issue a Redis `EXISTS` command on the set, so that if it just went empty will
return true and we will proceed to remove the user from `users_set_key` set.

## Listing all tokens for a service and application

This is the feature that requires tracking of tokens and users.

> The current implementation uses Redis operations that could lead to potential
> DoSes, because it obtains the members of an arbitrarily big set in a single go.
>
> We expect this limitation to be solved incrementally in the future as set sizes
> grow. The reasoning behind this is that we lack a way to ask for certain ranges
> in the endpoint (or a way to stream results) and we don't yet use Redis' scan
> support anywhere in the codebase to avoid blocking the database.

When we list the tokens for a given service and application, we want to list
*all* of them, that is, including user-specific tokens. We also support listing
those that apply to a single user alone.

Additionally, we want to take the opportunity to make some janitorial work.
Because tokens can expire, we check that they are still valid, and if not, do
all the related housekeeping.

When we are done, we return the tokens in an array.

### Redis steps

First thing we do is getting the members of the `token_set_key` set. This should
include all the tokens we're interested in if a user_id was given. If it was not
given, then we get all the members of the `users_set_key` and assemble an array
with all the known users and their respective tokens, using the same principle
as if a user_id was given.

So for each token we got, we build its `token_key` and get it from Redis. If the
result was not nil, it means we got a correct application id, and thus create
a new `OAuthTokenStorage` object ready to be returned.

If the result *was* nil, it means that token is no longer valid (expired). In
that case, we remove the token from the `token_set_key` set. If that set just
became empty, we then remove the user from the `users_set_key` set, just the
same as when deleting.

# Authorization

Authorization is granted or denied based on the application id that the token
points to. Obviously, no authorization will occur if there is no such mapping.

When authorizing, we can just read the `token_key` and validate it is not empty.
The appearance of user_ids opens some questions.

Currently we have opted for maintaining this method, at the cost of not adding
extra consistency checks which would result in higher response times.

This also translates into needing extra checks elsewhere for consistency. Also,
since we decide to include the user id in the key value instead of in the key
itself, we can still ensure that all tokens are unique across a service.

## Design discussion

However, an open discussion point is whether we should _ALSO_ check for
consistency at this point. Some cases arguably benefit from the consistency
check, for example when a user_id is passed in, because you generally want to
accept only the tokens that a specific user is allowed to use, not other user's
tokens. If we did not do this, any and all tokens would effectively become
application-wide tokens, and user_ids would become more a cosmetic feature for
grouping tokens than a real enforcing filter.

Past implementations checked that the `token_set_key` set contains the token for
consistency. If no user_id was given, that's the application-wide token set, and
if the membership test failed an error would be returned. If an user_id was
provided, the code checked the application-wide token set before giving up.

The current implementation checks that the user_id given is the owner of the
token because it checks the embedded user id in the token_key's value. Other
than that, there is no extra check, and we could have an inconsistent state if
we had a transaction interrupted when deleting (ie. we do not have real
transactions). That's why we try to first delete the token key, then the token
and user from their respective sets.

The following questions arise:

* Should we always check that a token is included in the `token_set_key` set?
  Especially relevant for when no user_id is present (app-wide sets), because
  otherwise they would be served with a single Redis request.

  ANSWER: we have preemptively chosen to keep a single Redis request by adding
  the user_id to the key format. This poses problems to ensure tokens are unique
  across users of a service.

* Should we fall back to application-wide tokens if a user_id was specified and
  the token does not exist in the user's `token_set_key` set?

  ANSWER: Currently we do NOT fall back. Application-wide tokens only authorize
  non-user specific requests. User-specific requests lookup tokens registered
  for that specific user and nothing else.
